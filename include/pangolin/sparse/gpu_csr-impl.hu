#pragma once

#include "gpu_csr.hu"
#include "pangolin/logger.hpp"

#ifdef __CUDACC__
#define PANGOLIN_CUDA_MEMBER __host__ __device__
#else
#define PANGOLIN_CUDA_MEMBER
#endif 

namespace pangolin {

template<typename Index>
PANGOLIN_CUDA_MEMBER uint64_t GPUCSR<Index>::num_rows() const { 
    if (rowOffset_.size() == 0) {
        return 0;
    } else {
        return rowOffset_.size() - 1;
    }
}

template<typename Index>
uint64_t GPUCSR<Index>::num_nodes() const { 
    std::set<Index> nodes;
    // add all dsts
    for (Index ci = 0; ci < col_.size(); ++ci) {
        nodes.insert(col_[ci]);
    }
    // add non-zero sources
    for (Index i = 0; i < rowOffset_.size() - 1; ++i) {
        Index row_start = rowOffset_[i];
        Index row_end = rowOffset_[i+1];
        if (row_start != row_end) {
            nodes.insert(i);
        }
    }
    return nodes.size();
}

template<typename Index>
GPUCSR<Index> GPUCSR<Index>::from_edgelist(const EdgeList &es, bool (*edgeFilter)(const Edge &)) {
    GPUCSR<Index> csr;

    
    if (es.size() == 0) {
        LOG(warn, "constructing from empty edge list");
        return csr;
    }


    for (const auto &edge : es) {

        // edge has a new src and should be in a new row
        // even if the edge is filtered out, we need to add empty rows
        while (csr.rowOffset_.size() != size_t(edge.first + 1))
        {
            // expecting inputs to be sorted by src, so it should be at least
            // as big as the current largest row we have recored
            assert(edge.first >= csr.rowOffset_.size());
            // TRACE("node {} edges start at {}", edge.src_, csr.edgeSrc_.size());
            csr.rowOffset_.push_back(csr.col_.size());
        }

        // filter or add the edge
        if (nullptr != edgeFilter && edgeFilter(edge)) {
            continue;
        } else {
            csr.col_.push_back(edge.second);
        }
    }

    // add the final length of the non-zeros to the offset array
    csr.rowOffset_.push_back(csr.col_.size());

    return csr;
}


} // namespace pangolin
#ifdef PANGOLIN_CUDA_MEMBER
#undef PANGOLIN_CUDA_MEMBER
#endif